from  pylurk.extensions.tls13_lurk_struct import *
from  pylurk.extensions.tls13_tls13_struct import *
from secrets import token_bytes

## from pylurk.utils.utils import set_title
## cannot import because construct 2.10 does not support Embedded 

## TODO:
# import from utils.py instead of copying the fucntion

def title(title):
    """ print title in a square box

    To enhance the readability of the tests, this function prints in the
    terminal teh string title in a square box.

    Args:
        title (str): the string
    """
    space = "    "
    title = space + title + space
    h_line = '+'
    for character in title:
        h_line += '-'
    h_line += '+\n'
    print('\n' + h_line + '|' + title + '|\n' + h_line )


def test_struct( struct, data_struct, ctx_struct={}, \
                 ext_title='', no_title=False, \
                 io_check=True ):
  """ checks the Extension """
 
  if not no_title: 
    title("Testing %s [%s]  structure"%(struct.__class__.__name__, ext_title))
  binary = struct.build(data_struct, **ctx_struct)
  data = struct.parse(binary, **ctx_struct)
  print("struct: %s"%data_struct)
  print("bytes: %s"%binary)
  print("struct: %s"%data)
  if io_check:
    assert ( data_struct == data )
  return binary, data

## I LURK extensions for TLS 1.3 structures 

## KeyRequest
data_struct = {"b":True, "e_s":False, "e_x":True, "h_c":False,\
               "h_s":True, "a_c":False, "a_s":True, "x":False, \
               "r":True}
binary, struct = test_struct(KeyRequest, data_struct, io_check=False)
assert(len(binary) == 2)
data_struct['reserved'] = 0
assert(data_struct == struct) 

title("Testing Secret structure")

## Secret
secret_data = b'secret'
for secret_type in ['b', 'e_s', 'e_x', 'h_c', 'h_s', 'a_c', 'a_s', 'x', 'r']:
  data_struct = {'secret_type': secret_type, 'secret_data': secret_data}
  test_struct(Secret, data_struct, ext_title=secret_type)

## Extensions
psk = { 'extension_type': 'psk_id', \
        'extension_data': { 'identity': b'key_identity',\
                            'obfuscated_ticket_age': b'\x00\x01\x02\x03'} }
secret = {'secret_type': 'x', 'secret_data': b'secret'}
eph = { 'extension_type': 'ephemeral',\
        'extension_data': { 'ephemeral_method': 'secret_provided',\
                            'secrets': [secret, secret] } }
frsh = { 'extension_type': 'freshness', 'extension_data': 'sha256'}
sess = { 'extension_type': 'session_id',\
         'extension_data': b'\x00\x01\x02\x03' }
all_ext = [ psk, eph, frsh, sess ]

for ext in all_ext:
  test_struct(LURK13Extension, ext, ext_title=ext['extension_type'])

## SessionID
session_id = {'session_id': b'\x00\x01\x02\x03' }
test_struct(SessionID, session_id)

## SecretRequest
key_req = {"b":True, "e_s":False, "e_x":True, "h_c":False,\
            "h_s":True, "a_c":False, "a_s":True, "x":False, \
            "r":True}
handshake_ctx =b'\x00\x01\x02'
sec_req = {'key_request': key_req, \
           'handshake_contex': handshake_ctx, \
           'extension_list': all_ext }
binary, struct = test_struct(SecretRequest, sec_req, io_check=False)
sec_req['key_request']['reserved']=0
assert( struct == sec_req)

## SecretResponse
a_c = {'secret_type': 'a_c', 'secret_data': b'secret_ac'}
a_s = {'secret_type': 'a_s', 'secret_data': b'secret_as'}
sec_resp = {'secret_list' : [a_c, a_s], 'extension_list': all_ext}
test_struct(SecretResponse, sec_resp)

## SignatureRequest
key = { 'key_id_type' : 'sha256_32', 'key_id' : b'\x00\x01\x02\x03' }
cert_32 = { 'certificate_type' : 'sha256_32',\
            'certificate_data' : b'\x00\x01\x02\x03' }

cert_entry = {'cert' : b'\x00\x01\x02\x03',\
              'extensions':[] }
cert_tls = {'certificate_request_context' : b'\x00\x01', \
        'certificate_list' : [cert_entry, cert_entry]}
cert_x509 = { 'certificate_type' : 'X509', \
              'certificate_data' : cert_tls}

for cert in [cert_32, cert_x509]:
  sig_req = {'key_id': key, \
             'sig_algo' : 'rsa_pkcs1_sha256' ,\
             'certificate' : cert }
  test_struct(SigningRequest, sig_req)

## SignatureResponse
sig_resp = { 'signature' :  b'\x00\x01\x02\x03' }
test_struct(SigningResponse, sig_resp)

##  TLS Server: EarlySecret
early_sec_req = {'secret_request' : sec_req }
binary, struct = test_struct(EarlySecretRequest, early_sec_req, io_check=False)
early_sec_req['secret_request']['key_request']['reserved']=0
assert( struct == early_sec_req)

early_sec_resp = {'secret_response' : sec_resp}
test_struct(EarlySecretResponse, early_sec_resp)

## TLS server InitCertificateVErify
init_cert_verif_req = {'secret_request':sec_req, \
                        'signing_request':sig_req }
binary, struct = test_struct(InitCertificateVerifyRequest,\
                             init_cert_verif_req, io_check=False)
init_cert_verif_req['secret_request']['key_request']['reserved']=0
assert( struct == init_cert_verif_req)

init_cert_verif_resp = {'secret_response' : sec_resp, \
                        'signing_response' : sig_resp }
test_struct(InitCertificateVerifyResponse, init_cert_verif_resp)

## HandshakeRequest

for session_id_agreed in [True, False]:
  ctx_struct = {'session_id_agreed' : session_id_agreed }
  hand_req = {'session_id': b'\x00\x01\x02\x03', \
               'secret_request':sec_req }
  test_struct(HandshakeRequest, hand_req , ctx_struct=ctx_struct,\
              io_check=False)

for session_id_agreed in [True, False]:
  ctx_struct = {'session_id_agreed' : session_id_agreed }
  hand_resp = {'session_id': b'\x00\x01\x02\x03', \
             'secret_response' : sec_resp }
  test_struct(HandshakeResponse, hand_resp , ctx_struct=ctx_struct,\
              io_check=False)

## NewSessionTicket

new_session_ticket = { \
  'ticket_lifetime':5,\
  'ticket_age_add':6,\
  'ticket_nonce':b'\x07', \
  'ticket':b'\x00\x01\x02\x03',\
  'extensions':[]\
}

nst_req = {\
  'session_id':b'\x00\x01\x02\x03', \
  'ticket_nbr':6,\
  'key_request':key_req, 
  'handshake_context':b'\xff\xff\xff\xff'\
}
test_struct(NewSessionTicketRequest, nst_req, io_check=False)

nst_resp = {\
  'session_id':b'\x00\x01\x02\x03', \
  'ticket_list': [ new_session_ticket,  new_session_ticket]
}

test_struct(NewSessionTicketResponse, nst_resp)


## II TLS 1.3 structures

## signature_algorithms
sig_list = [
  'rsa_pkcs1_sha256', 
  'rsa_pkcs1_sha384',
  'ecdsa_secp256r1_sha256', 
  'ecdsa_secp384r1_sha384',
  'ed25519', 'ed448'
  ]
sig_scheme_list = { 'supported_signature_algorithms' : sig_list}
test_struct(SignatureSchemeList, sig_scheme_list)

ext13 = {'extension_type': 'signature_algorithms', \
         'extension_data' : sig_scheme_list }
test_struct(Extension, ext13)

## psk_key_exchange_modes
psk_modes = {'ke_modes' : ['psk_ke', 'psk_dhe_ke']}

test_struct( PskKeyExchangeModes, psk_modes)

ext45 = {'extension_type': 'psk_key_exchange_modes', \
         'extension_data' : psk_modes }
test_struct(Extension, ext45)

## post-handshake authentication
ext49 = {'extension_type': 'post_handshake_auth', \
         'extension_data' : {} }
test_struct(Extension, ext49)

## supported_group

grp = {'named_group_list' : ['secp256r1', 'secp384r1', 'x25519', 'x448' ]}
test_struct(NamedGroupList, grp)

ext10 = {'extension_type': 'supported_groups', \
         'extension_data' : grp }
test_struct(Extension, ext10)

## key_share
## Extensions build/parse is checked using the KeyShare structure that
## reads the msg_type parameter at the contructor level. Extension reads
## it two level above. 
ke_entry = {'group': 'secp256r1', 'key_exchange' : b'\xff\xff\xff\xff'}
ks_ch = {'client_shares' : [ke_entry, ke_entry]}
test_struct(KeyShareClientHello, ks_ch)
ks_hr = {'selected_group' : 'x448' }
test_struct(KeyShareHelloRetryRequest, ks_hr)
ks_sh = {'server_share' : ke_entry }
test_struct(KeyShareServerHello, ks_sh)

ext51_ch = {'extension_type': 'key_share', \
         'extension_data' : ks_ch }
ctx_struct = {'msg_type' : 'client_hello'}
test_struct(KeyShareExt, ext51_ch, ctx_struct=ctx_struct)

ext51_hr = {'extension_type': 'key_share', \
         'extension_data' : ks_hr }
ctx_struct = {'msg_type' : 'client_hello'}
test_struct(KeyShareExt, ext51_hr, ctx_struct=ctx_struct)

ext51_sh = {'extension_type': 'key_share', \
         'extension_data' : ks_sh }
ctx_struct = {'msg_type' : 'server_hello'}
test_struct(KeyShareExt, ext51_sh, ctx_struct=ctx_struct)

## pre_shared_key
psk_id = {'identity' : b'\x00\x00', \
          'obfuscated_ticket_age' : b'\x00\x01\x02\x03' }
psk_binder = {'binder' : b'\xff\xff\xff\xff'}
offered_psk = { 'identities' : [psk_id, psk_id], \
        'binders' : [psk_binder, psk_binder]}

test_struct(OfferedPsks, offered_psk)

## III TLS messages
## Some Extensions have different structures depending on the msg_type
## parameter. As a result, it is preferred to test the message via the
##  Handshake structure. 

## client_hello
random = token_bytes( 32 )
client_hello = {\
  'legacy_version' : b'\x03\x03',
  'random' : random,
  'cipher_suites' : ['TLS_AES_128_GCM_SHA256', 'TLS_CHACHA20_POLY1305_SHA256'],
  'legacy_compression_methods' : b'\x00',
  'extensions' : [ext49]
  }
test_struct(ClientHello, client_hello)

client_hello['extensions'].append(ext51_ch)
ctx_struct = {'msg_type': 'client_hello'}
test_struct(ClientHello, client_hello, ctx_struct=ctx_struct)

hs_client_hello = {'msg_type': 'client_hello', 'data' : client_hello}

test_struct(Handshake, hs_client_hello)

## server_hello

server_hello = {
  'legacy_version' : b'\x03\x03',
  'random' : random,
  'cipher_suite' :'TLS_AES_128_GCM_SHA256',
  'legacy_compression_method' : b'\x00',
  'extensions' : [ext49, ext51_sh]
  }
test_struct(ClientHello, client_hello)






  

